"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPgStructure = void 0;
const pg_structure_1 = __importDefault(require("pg-structure"));
const postgres_numeric_types_1 = require("../enums/postgres-numeric-types");
const indexedArrayToArray = (arr, operation, restriction) => {
    if (!arr) {
        return [];
    }
    const newArr = [];
    arr.forEach((element) => {
        if (!restriction || (restriction && restriction(element)))
            if (element) {
                newArr.push(operation(element));
            }
    });
    return newArr;
};
const buildMExpressions = (column) => {
    if (typeof column === "string") {
        return column;
    }
    return undefined;
};
const buildMColumn = (column) => {
    if (typeof column === "string") {
        return undefined;
    }
    if (!column || !column.type) {
        return undefined;
    }
    return {
        name: column.name,
        dataType: typeof column.type === "object" &&
            typeof column.type !== null &&
            typeof column.type !== "string"
            ? column.type.name
            : "no type",
        internalName: typeof column.type === "object" &&
            typeof column.type !== null &&
            typeof column.type !== "string"
            ? column.type.internalName
            : "no type",
        isNull: !column.notNull,
        length: column.length,
        isForeignKey: column.isForeignKey,
        isPrimaryKey: column.isPrimaryKey,
        fullCatalogName: column.fullCatalogName,
        minValue: column.minValue,
        maxValue: column.maxValue,
        indexes: indexedArrayToArray(column.indexes, buildMIndexName),
    };
};
const buildMIndex = (index) => {
    if (!index) {
        return undefined;
    }
    return {
        name: index.name,
        relatedColumns: indexedArrayToArray(index.columnsAndExpressions, buildMColumn, (element) => typeof element !== "string"),
        relatedExpressions: indexedArrayToArray(index.columnsAndExpressions, buildMExpressions, (element) => typeof element === "string"),
    };
};
const buildMIndexName = (index) => {
    if (!index) {
        return undefined;
    }
    return {
        name: index.name
    };
};
const buildMConstraint = (constraint) => {
    var _a;
    if (!constraint) {
        return undefined;
    }
    return {
        name: constraint === null || constraint === void 0 ? void 0 : constraint.name,
        type: constraint.constructor.name,
        comment: constraint === null || constraint === void 0 ? void 0 : constraint.comment,
        schema: (_a = constraint === null || constraint === void 0 ? void 0 : constraint.schema) === null || _a === void 0 ? void 0 : _a.name,
    };
};
const buildMTriggers = (trigger) => {
    return {
        name: trigger === null || trigger === void 0 ? void 0 : trigger.name,
        oid: trigger === null || trigger === void 0 ? void 0 : trigger.oid,
        category: trigger === null || trigger === void 0 ? void 0 : trigger.category,
        classOid: trigger === null || trigger === void 0 ? void 0 : trigger.classOid,
        comment: trigger === null || trigger === void 0 ? void 0 : trigger.comment,
        internalName: trigger === null || trigger === void 0 ? void 0 : trigger.internalName,
    };
};
const buildMForeignKey = (foreignKey) => {
    const mColumns = indexedArrayToArray(foreignKey === null || foreignKey === void 0 ? void 0 : foreignKey.columns, buildMColumn);
    return {
        name: foreignKey === null || foreignKey === void 0 ? void 0 : foreignKey.name,
        columns: mColumns,
        referencedColumns: indexedArrayToArray(foreignKey === null || foreignKey === void 0 ? void 0 : foreignKey.referencedColumns, buildMColumn),
        mandatoryParent: foreignKey === null || foreignKey === void 0 ? void 0 : foreignKey.mandatoryParent,
        index: buildMIndex(foreignKey === null || foreignKey === void 0 ? void 0 : foreignKey.index),
    };
};
const buildPrimaryKeyData = (primaryKey) => {
    const mColumns = indexedArrayToArray(primaryKey === null || primaryKey === void 0 ? void 0 : primaryKey.columns, buildMColumn);
    const sizeInBytes = mColumns.reduce((acc, cur) => {
        if (cur.length != undefined && cur.dataType === "character") {
            acc = acc + cur.length * 1;
        }
        if (cur.length === undefined) {
            acc = acc + (postgres_numeric_types_1.NumericTypesPgEnum[cur.dataType] || 0);
        }
        return acc;
    }, 0);
    const numOfColumns = mColumns === null || mColumns === void 0 ? void 0 : mColumns.length;
    return {
        name: primaryKey === null || primaryKey === void 0 ? void 0 : primaryKey.name,
        index: undefined,
        columns: mColumns,
        commentData: primaryKey === null || primaryKey === void 0 ? void 0 : primaryKey.commentData,
        sizeInBytes: sizeInBytes,
        numOfColumns: numOfColumns,
    };
};
const buildTable = (table) => {
    var _a, _b;
    if (!table) {
        return undefined;
    }
    return {
        name: table === null || table === void 0 ? void 0 : table.name,
        schemaName: (_a = table === null || table === void 0 ? void 0 : table.schema) === null || _a === void 0 ? void 0 : _a.name,
        tableId: table === null || table === void 0 ? void 0 : table.oid,
        columns: indexedArrayToArray(table.columns, buildMColumn),
        indexes: indexedArrayToArray(table.indexes, buildMIndex),
        constraints: indexedArrayToArray(table.constraints, buildMConstraint),
        triggers: indexedArrayToArray(table.triggers, buildMTriggers),
        pkData: buildPrimaryKeyData(table.primaryKey),
        pk: ((_b = table === null || table === void 0 ? void 0 : table.primaryKey) === null || _b === void 0 ? void 0 : _b.name) || "no-pk",
        fk: indexedArrayToArray(table === null || table === void 0 ? void 0 : table.foreignKeys, buildMForeignKey),
    };
};
const buildSchema = (schema) => {
    if (!schema) {
        return [];
    }
    return {
        name: schema.name,
        tables: indexedArrayToArray(schema.tables, buildTable),
    };
};
const getPgStructure = (client) => __awaiter(void 0, void 0, void 0, function* () {
    const db = yield (0, pg_structure_1.default)(client, { keepConnection: true });
    return indexedArrayToArray(db.schemas, buildSchema) || [];
});
exports.getPgStructure = getPgStructure;
//# sourceMappingURL=pg-structure-resource.js.map